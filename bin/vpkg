#!/usr/bin/env bash

# requires: git, mr, vcsh, curl

# utility functions
on_error() {
    local prog fun lineno rc
    prog=$(basename $0)
    read -r fun lineno rc <<< "$@"
    echo "error at ${fun} in ${prog}:${lineno} with exit code ${rc}."
    [[ -z "${VPKG_DEBUG}" ]] || caller
    exit ${rc}
}

error() {
    local message
    read -r message <<< "$@"
    echo "Error: ${message}."
    exit 1
}

usage() {
    echo "Usage: vpkg COMMAND [OPTIONS]"
    echo
    echo "Commands:"
    echo "  add - add a vim plugin"
    echo "  delete - remove a vim plugin"
    echo "  list - list installed plugins"
    echo "  update - update vim configuration"
    echo "  push - push local changes to the repository."
    exit 0
}

# make sure mr is not an alias
mr() {
   command mr -mqs "$@"
}

spinner() {
    trap "tput cnorm; exit" TERM
    local -a spinner
    spinner=("◴" "◷" "◶" "◵")
    tput civis
    while :; do
        for ((i=0; i<${#spinner[@]}; i++)); do
            printf ${spinner[$i]}
            sleep .1
            printf "\b"
        done
    done
}

# work around places that don't use reasonable find
find() {
    if command -v gfind &>/dev/null; then
        cmd="gfind"
    elif command -v find &>/dev/null; then
        cmd="find"
    else
        error "no suitable find command found"
    fi
    command ${cmd} "$@"
}

# use git to manage .ini config files
initool() {
    command git config "$@"
}

# check if the URI is valid
uri_exists() {
    local uri status
    read -r uri <<< "$@"
    status=$(curl -s -o /dev/null -w "%{http_code}" "${uri}")
    if [[ "${status}" =~ [23][0-9][0-9] ]]; then
        return 0
    else
        return 1
    fi
}

# check if github repo exists
github_exists() {
    local user name status
    read -r user name <<< "$@"
    uri="https://api.github.com/repos/${user}/${name}"
    status=$(curl -s -o /dev/null -w "%{http_code}" "${uri}")
    if [[ "${status}" =~ [2][0-9][0-9] ]]; then
        return 0
    else
        return 1
    fi
}

git_exists() {
    local uri status rc
    read -r uri <<< "$@"
    status=$(rc=0; git ls-remote "${uri}" &>/dev/null || rc=$?; echo $rc)
    if [[ "${status}" == 128 ]]; then
        return 1
    else
        return 0
    fi
}

reexec() {
    local message="$@"
    echo "${message}"
    exec "$0" "${BASH_ARGV[*]}"
}

# plugin management

plugin::list() {
    awk '$0 ~ /\[.*\]/ && $0 !~ /DEFAULT/ { gsub(/[\[\]]/, ""); print }' "${mrconfig}"
}

plugin::add() {
    local src name uri user
    src="$1"; shift
    case "${src}" in 
        github)
            read -r user name <<< "$@"
            plugin::add::github "${user}" "${name}" && plugin::register "${name}"
            ;;
        git)
            read -r uri name <<< "$@"
            : ${name:=$(basename ${uri/#@(http?|git*|ssh):\/\/} .git)}
            plugin::add::git "${name}" "${uri}" && plugin::register "${name}"
            ;;
    esac
}

plugin::add::github() {
    local user name uri
    read -r user name <<< "$@"
    github_exists "${user}" "${name}" || error "no github repository ${name} found for user ${user}"
    uri="https://github.com/${user}/${name}.git/"
    plugin::add::git "${name}" "${uri}"
}

plugin::add::git() {
    local name uri
    read -r name uri <<< "$@"
    git_exists "${uri}" || error "no git repository ${name} exists at ${uri}"
    [[ -d "${name}" ]] && error "plugin directory ${name} already exists" || git clone --recursive "${uri}" "${name}"
}

plugin::add::hg() {
    local name uri
    read -r name uri <<< "$@"
    [[ -d "${name}" ]] && return 1 || hg clone "${uri}" "${name}"
}

plugin::add::svn() {
    local name uri
    read -r name uri <<< "$@"
    [[ -d "${name}" ]] && return 1 || svn co "${uri}" "${name}"
}

plugin::update() {
    echo -n "Updating plugins... "; spinner & spid=$!
    mr update || (kill -TERM "${spid}"; echo " at least one of the repositories failed.") && (kill -TERM "${spid}"; echo " done.")
}

plugin::delete() {
    local name
    read -r name <<< "$@"
    [[ -d "${name}" ]] && rm -rf "${name}"
    plugin::unregister "${name}"
}

plugin::register() {
    local name
    read -r name <<< "$@"
    mr register "${name}"
    vcsh "${cfg_repo}" add "${mrconfig}"
    vcsh "${cfg_repo}" commit -m "Plugin ${name} registered in .mrconfig."
    if [[ -n "${vcsh_push}" ]]; then
        vcsh "${cfg_repo}" push
    fi
}

plugin::unregister() {
    local name
    read -r name <<< "$@"
    initool --file "${mrconfig}" --remove-section "${name}" || true
    vcsh "${cfg_repo}" add "${mrconfig}"
    vcsh "${cfg_repo}" commit -m "Plugin ${name} unregistered from .mrconfig."
    if [[ -n "${vcsh_push}" ]]; then
        vcsh "${cfg_repo}" push
    fi
}

plugin::sync() {
    local plugins dir
    local -a dirs
    plugins=$(plugin::list)
    while read -r dir; do
        dirs+=("${dir}")
    done < <(find "${bundles}" -type d -mindepth 1 -maxdepth 1 -printf "%f\n")
    for ((i=0; i<${#dirs[@]}; i++)); do
        dir="${dirs[$i]}"
        if [[ ! "${plugins}" == *${dir}* ]]; then
            rm -rf "${dir}" && echo "dangling directory removed: ${dir}."
        fi
    done
}

update::all() {
    config::update
    plugin::update
    plugin::sync
}

config::update() {
    local sha; sha="$(sha512sum "$0")"
    echo -n "Updating configuration... ";
    vcsh "${cfg_repo}" pull 2>&1 >/dev/null; echo "done."
    echo -n "${sha}" | sha512sum --check --status || reexec "$(basename $0) changed, re-executing"
}

vpkg::prep() {
    [[ -f "$HOME/.mrtrust" ]] || touch "$HOME/.mrtrust"
    grep -q "${mrconfig}" "$HOME/.mrtrust" || \
        echo "${mrconfig}" >> "$HOME/.mrtrust"
    for dir in bundle undo backup; do
        [ -d "${dir}" ] || mkdir -p "${vimdir}/${dir}"
    done
}

main() {
    # error handling
    [[ -z "${VPKG_DEBUG}" ]] || set -x
    set -o errexit
    set -o errtrace
    set -o pipefail
    #set -o nounset
    trap 'on_error ${FUNCNAME[0]} ${LINENO} ${?}' ERR INT HUP

    : "${VPKG_LOGFILE:=/dev/null}"
    exec 2>${VPKG_LOGFILE}

    # sanitize the environment a bit...
    for envvar in GIT_DIR VCSH_DIRECTORY VCSH_REPO_NAME VCSH_COMMAND; do
        unset "${envvar}"
    done

    export vimdir="$HOME/.vim"
    export bundles="${vimdir}/bundle"
    export mrconfig="${bundles}/.mrconfig"
    export cfg_repo="rc-vim"
    vpkg::prep

    cd "${bundles}"
    if [[ $# < 1 ]]; then
        set -- "help"
    fi
    action="$1"; shift
    case "${action}" in
        add)
            plugin::add "$@" ;;
        del|delete|remove)
            for plugin in "$@"; do
                plugin::delete "${plugin}"
            done
            ;;
        update)
            update::all ;;
        list)
            plugin::list ;;
        push)
            vcsh push ;;
        sync)
            plugin::sync ;;
        help|*)
            usage ;;
    esac
}

main $@
